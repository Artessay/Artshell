# My Shell

## 引言

命令行解释器作为操作系统中最基本的用户接口，是用户与操作系统底层直接打交道的必经之处。本实验要求通过程序设计语言实现shell 程序的基本功能，设计一个My Shell命令行解释器。

## 编译器前端构建

为了

## 内部命令实现

在最新的版本中，shell 程序支持以下内部命令：bg、cd 、clr、dir、echo 、exec 、exit 、fg 、help、jobs 、pwd 、set 、test 、time 、umask。这些命令的实现介绍如下。

### bg

bg命令的格式为：bg <job>

bg命令用于将被挂起的进程<job>转到后台。如果没有<job>参数，则默认将当前进程放到后台运行，相当于在命令后加上&符号。



### cd

cd命令的格式为：cd <directory>  

该命令可以把当前默认目录改变为<directory>。如果没有<directory>参数，则显示主目录。如该目录不存在，会出现相应的错误信息。

这个命令主要是通过`chdir()`函数来实现的。该函数可以将当前进程的工作目录切换到输入参数对应目录下，如果对应目录存在且能够正常打开，则会返回0，否则会返回相应的异常状态。我们通过该命令可以切换进程的工作目录，并且根据该函数的返回信息判断相应的错误情况给予用户以提示。

同时，这个命令也可以改变PWD环境变量，通过`setenv()`函数设置PWD的环境变量为切换后的工作目录，让环境变量与我们的shell中的工作目录保持逻辑上的一致性。

当然，其中有一项内容需要特殊处理，那就是用户输入中的**“\~”符号**。因为“\~”符号代表了用户的主目录，如果用户输入的目录以“\~”开头的话，我们需要在更改目录前先将用户的输入的“\~”字符转变为用户主目录的路径，然后再进行接下来的操作。

### clr

clr  是一个清屏命令。clr命令等价与普通shell中的clear命令，其作用是将显示屏幕上的内容全部清除干净。

依托丰富的不可见控制字符，Linux的输出控制变得十分简单而有趣了。通过向屏幕或者是输出文件上输出一些不可见的控制字符，我们可以很容易地改变屏幕或是这些输出文件里的输出的位置、输出字符的颜色、当前屏幕或文件的状态等等。而在清屏功能上亦是如此。

看上去将整个屏幕清除似乎不是十分容易，但其实通过向输出文件中打印**"\x1b[H\x1b[2J"**字符之后，所有原来文件中的内容就自动被清楚了，而在屏幕之上表现的效果便是清屏。

### dir

dir命令的命令格式为：dir <directory>  

该命令的功能是列出目录<directory>的内容。如果没有<directory>参数，则显示当前目录内容。在实现上，dir命令与cd命令有许多异曲同工之处，二者都是对目录进行操作。

与cd命令类似，dir命令之中也需要对用户可能查询命令中的“\~”字符进行特殊的替换处理。将“\~”字符替换为用户的主目录后可以保证程序以正确的方式继续运行。

### echo

echo命令的格式为：echo <comment> 

echo命令用于在屏幕上显示<comment>并换行，其中多个空格和制表符被缩减为一个空格。

由于在前期flex解析的时候已经将用户所有的输入根据空白符进行划分进行了解析，因此在实现echo命令时，我们只需要将echo命令之后的参数逐一输出，中间以一个空格分开，在所有内容输出完毕之后再输出一个换行符即可。

### exec

exec命令的命令格式为：exec <command> 

exec命令用于执行命令<command>，并且将该命令对应的代码覆盖当前运行这个命令的进程的代码，以执行新的命令替换 当前的shell进程。

在C语言的库中包含有exec一系列的函数可以帮助我们在C程序中实现执行exec命令。我们可以使用运行指令向量的`execvp()`函数实现调用exec命令。

需要注意的是，在我们使用execvp函数时，此时我们解析语法中的命令第一个命令为exec，因此我们向函数传参时要去掉第一个命令，从第二个参数开始传给execvp。此外，如果用户输入中只有一个exec命令而没有其他参数，那么shell应该不做任何处理，相当于什么命令都没有执行。

### exit

exit命令可以退出当前shell。

在My Shell命令行解释器中，所有执行的命令最后都会带回一个返回状态。其中设置的一个状态就是SH_EXIT状态用于判断是否执行的是退出命令。当用户输入exit命令后，该命令正常执行完会返回SH_EXIT状态，主程序循环的shell检测到上一条命令执行完成时的状态为退出状态后便会自动结束shell，退出程序。

### fg

fg <job> ——将后台运行或挂起的作业<job>切换到前台运行。如果没有<job>参数，则默认将当前进程放到后台运行。



### help

help 命令可以显示用户手册。

在程序所在的doc目录下存放了供用户阅读的用户手册，当用户输入help命令后，程序会读取doc目录下的用户手册并将其显示在屏幕上。使用more 命令可以过滤用户手册的信息。

### jobs

jobs <job> ——显示所有挂起的和后台进程的作业号及状态。如果没有列表，则显示当前进程的状态。



### pwd

pwd 命令的功能是显示当前目录。

pwd命令的实现非常简单，只要将控制台存储的当前工作目录输出到显示处，让负责处理输出的显示终端根据需要在对应的输出文件上打出当前工作目录的输出即可。

### set

set命令用于列出系统中所有的环境变量。

在C语言程序运行时，系统会自动将输入给C语言程序的参数格式argc，参数列表argv，以及对应的所有环境变量列表env传递传递给C语言程序的main函数。因此，一个标准的main函数可以写成如下的形式：

~~~c
int main(int argc, char argv[], char **env)
{
    /*some main part*/
    return 0;
}
~~~

在这个程序里，我们可以直接通过传入main函数的env变量来获取当前程序所处在系统中的所有环境变量，并通过一个while循环将所有环境变量逐一打印便可列出系统中所有的环境变量了。

### test

test <expression> ——检测表达式<expression>返回true还是false。



### time

time 命令用于显示当前时间。需要注意的是，这里的time命令并不是指Linux当中用于计时的time命令，而是date命令——显示当前的日期与时间等相关信息。

在C语言gcc编译器提供的glibc等许多库里包含丰富的系统调用函数，其中在time.h的头文件里定义了time_t的时间获取指针，tm的结构体以及相应的函数能够帮助我们快速系统时间。

与此同时，time库里面还包含了`strftime()`的函数能够形式化的打印时间结构体中的各种参数，以任何我们所期望的形式。比如通过%c的控制符就可以打印出符合当前区域设置的首选日期和时间表现形式的日期格式。我们将打印出的信息传给显示器进行显示即可。关于strftime函数的具体格式说明可以参考下面这张图片：

<img src="../img/strftime.png" alt="strftime" style="zoom:60%;" />



### umask

umask <mask> ——设定新创建文件或目录的访问特权。如果没有<mask>参数，则显示当前设置的掩码。

<mask>是位的掩码，用八进制表示。掩码位为1表示新创建的文件相应的访问特权应该被关闭



## 环境变量设置

shell 运行时的环境变量将包含shell环境变量，其格式如下所示，其中<pathname>/myshell 是可执行程序shell 的完整路径。

~~~shell
shell=<pathname>/myshell
~~~



当shell中遇到了上述提到的内部命令之外的**其他的命令行输入**时，这些命令会被解释为**程序调用**，shell 创建并执行这个程序，并作为自己的子进程。在子程序的执行的环境里，系统环境变量将包含parent环境变量，其格式如下所示。

~~~shell
parent=<pathname>/myshell。
~~~



在C语言中，设置环境变量并不是一件十分复杂的事情。在stdlib库里有`setenv()`的函数可以帮助我们设置环境变量。在程序运行开始时我们设置shell环境变量，在每次创建子进程时在子进程中设置parent环境变量即可实现上述功能。



## 批处理文件执行

除了直接从终端的命令行中读入用户一条条命令的输入之外，shell也支持从文件中提取命令行输入。在shell中输入myshell加上所要执行的批处理文件名便可以从这些文件中读入命令行输入。

例如，用户可以在shell中使用以下命令行调用批处理：

~~~shell
$ myshell batchfile 
~~~



在这个命令中，batchfile是我们要执行的一个批处理文件，这个批处理文件可以包含一组命令集。调用此命令后shell会依次执行该命令集中的每条命令，当到达文件结尾时shell 退出返回到直接调用myshell时的状态。

如果shell 被调用时没有使用参数，则会在屏幕上显示提示符'> '请求用户输入批处理文件。

shell支持**同时处理多个批处理文件**，这些批处理文件会按照输入的顺序逐一解析执行。

批处理文件的执行主要涉及到文件操作以及输入的重定向。在解析到用户输入了myshell命令之后，执行器首先要判断之后是否有输入参数。如果没有输入参数的话需要在终端显示提示符并不断读取用户输入，直到用户提供了正确的输入。此时我们还需要对用户的正确输入进行解析以确保能够获取正确的文件名。

在用户输入解析完成后，shell对逐一打开用户输入的各组文件，并将这些文件作为输入的重定向传入给另一个shell循环之中，对从这些文件读入的内容按照正常终端读入的方式读取和执行。在所有文件执行结束后需要将文件关闭。



## I/O 重定向

(四)	 shell 必须支持I/O 重定向，stdin 和stdout，或者其中之一，例如命令行为：
programname arg1 arg2 < inputfile > outputfile 
使用arg1 和arg2 执行程序programname，输入文件流被替换为inputfile，输出文件流被替换为outputfile。
stdout 重定向应该支持以下内部命令：dir、environ、echo、help。
使用输出重定向时，如果重定向字符是>，则创建输出文件，如果存在则覆盖之；如果重定向字符为>>，也会创建输出文件，如果存在则添加到文件尾。



## 后台程序执行

(五)	 shell 必须支持后台程序执行。如果在命令行后添加&字符，在加载完程序后需要立刻返回命令行提示符。





## 管道操作

(六)	 必须支持管道（“|”）操作。



## 路径显示

当用户在终端进入shell且用户命令的输出需要在终端显示时，命令行提示符将会显示当前使用用户的用户名称，用户所使用的机器名称以及用户当前所处在的工作目录的路径。其显示格式如下：

~~~shell
<username>@<hostname>:<current working dictionary>
~~~

为了让用户终端的显示更加丰富多彩，shell命令行的输出被赋予了丰富的颜色。在
30 (黑色), 31 (红色), 32 (绿色), 33 (黄色), 34 (蓝色), 35 (洋红), 36 (青色), 37 (白色)





项目要求：
1. 写一个关于如何使用shell 的简单的用户手册，用户手册应该包含足够的细节以方便Linux初学者使用。例如：你应该解释I/O 重定向、管道、程序环境和后台程序执行。

   

vfork() 出来的进程与父进程共享变量，堆栈，内存虚拟地址，子进程修改变量值，父进程对应的变量也变了；

vfork() 出来的子进程会导致父进程挂起（暂停运行），直到子进程调用 _exit() 函数退出，才会继续运行父进程，子进程如果不退出而是 return 会导致异常；

此外 vfork() 子进程也不能使用 exit() 函数来退出，因为这可能会调用到父进程的 exit() 函数，导致父进程退出，并刷新父进程输入输出（stdio）缓存，因此子进程一定是调用 _exit() 函数来退出。

