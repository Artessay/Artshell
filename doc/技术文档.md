# My Shell

## 引言

命令行解释器作为操作系统中最基本的用户接口，是用户与操作系统底层直接打交道的必经之处。本实验要求通过程序设计语言实现shell 程序的基本功能，设计一个My Shell命令行解释器。

## 内部命令实现

在最新的版本中，shell 程序支持以下内部命令：bg、cd 、clr、dir、echo 、exec 、exit 、fg 、help、jobs 、pwd 、set 、test 、time 、umask。这些命令的实现介绍如下。

### bg





### cd

cd命令的格式为：cd <directory>  

该命令可以把当前默认目录改变为<directory>。如果没有<directory>参数，则显示主目录。如该目录不存在，会出现相应的错误信息。

这个命令主要是通过`chdir()`函数来实现的。该函数可以将当前进程的工作目录切换到输入参数对应目录下，如果对应目录存在且能够正常打开，则会返回0，否则会返回相应的异常状态。我们通过该命令可以切换进程的工作目录，并且根据该函数的返回信息判断相应的错误情况给予用户以提示。

同时，这个命令也可以改变PWD环境变量，通过`setenv()`函数设置PWD的环境变量为切换后的工作目录，让环境变量与我们的shell中的工作目录保持逻辑上的一致性。

### clr

clr  是一个清屏命令。clr命令等价与普通shell中的clear命令，其作用是将显示屏幕上的内容全部清除干净。

依托丰富的不可见控制字符，Linux的输出控制变得十分简单而有趣了。通过向屏幕或者是输出文件上输出一些不可见的控制字符，我们可以很容易地改变屏幕或是这些输出文件里的输出的位置、输出字符的颜色、当前屏幕或文件的状态等等。而在清屏功能上亦是如此。

看上去将整个屏幕清除似乎不是十分容易，但其实通过向输出文件中打印**"\x1b[H\x1b[2J"**字符之后，所有原来文件中的内容就自动被清楚了，而在屏幕之上表现的效果便是清屏。

### dir

dir命令的命令格式为：dir <directory>  

该命令的功能是列出目录<directory>的内容。在实现上，dir命令与cd命令有许多异曲同工之处，二者都是对目录进行操作。

### echo

echo命令的格式为：echo <comment> 

echo命令用于在屏幕上显示<comment>并换行，其中多个空格和制表符被缩减为一个空格。

由于在前期flex解析的时候已经将用户所有的输入根据空白符进行划分进行了解析，因此在实现echo命令时，我们只需要将echo命令之后的参数逐一输出，中间以一个空格分开，在所有内容输出完毕之后再输出一个换行符即可。

### exec



### exit

exit命令可以退出当前shell。

在My Shell命令行解释器中，所有执行的命令最后都会带回一个返回状态。其中设置的一个状态就是SH_EXIT状态用于判断是否执行的是退出命令。当用户输入exit命令后，该命令正常执行完会返回SH_EXIT状态，主程序循环的shell检测到上一条命令执行完成时的状态为退出状态后便会自动结束shell，退出程序。

### fg





### help

help 命令可以显示用户手册。

在程序所在的doc目录下存放了供用户阅读的用户手册，当用户输入help命令后，程序会读取doc目录下的用户手册并将其显示在屏幕上。使用more 命令可以过滤用户手册的信息。

### jobs





### pwd

pwd 命令的功能是显示当前目录。

pwd命令的实现非常简单，只要将控制台存储的当前工作目录输出到显示处，让负责处理输出的显示终端根据需要在对应的输出文件上打出当前工作目录的输出即可。

### set

set命令用于列出系统中所有的环境变量。

在C语言程序运行时，系统会自动将输入给C语言程序的参数格式argc，参数列表argv，以及对应的所有环境变量列表env传递传递给C语言程序的main函数。因此，一个标准的main函数可以写成如下的形式：

~~~c
int main(int argc, char argv[], char **env)
{
    /*some main part*/
    return 0;
}
~~~

在这个程序里，我们可以直接通过传入main函数的env变量来获取当前程序所处在系统中的所有环境变量，并通过一个while循环将所有环境变量逐一打印便可列出系统中所有的环境变量了。

### test





### time

time 命令用于显示当前时间。需要注意的是，这里的time命令并不是指Linux当中用于计时的time命令，而是date命令——显示当前的日期与时间等相关信息。

在C语言gcc编译器提供的glibc等许多库里包含丰富的系统调用函数，其中在time.h的头文件里定义了time_t的时间获取指针，tm的结构体以及相应的函数能够帮助我们快速系统时间。

与此同时，time库里面还包含了`strftime()`的函数能够形式化的打印时间结构体中的各种参数，以任何我们所期望的形式。比如通过%c的控制符就可以打印出符合当前区域设置的首选日期和时间表现形式的日期格式。我们将打印出的信息传给显示器进行显示即可。关于strftime函数的具体格式说明可以参考下面这张图片：

<img src="../img/strftime.png" alt="strftime" style="zoom:60%;" />



### umask





## 环境变量设置

shell 运行时的环境变量将包含shell环境变量，其格式如下所示，其中<pathname>/myshell 是可执行程序shell 的完整路径。

~~~shell
shell=<pathname>/myshell
~~~



当shell中遇到了上述提到的内部命令之外的**其他的命令行输入**时，这些命令会被解释为**程序调用**，shell 创建并执行这个程序，并作为自己的子进程。在子程序的执行的环境里，系统环境变量将包含parent环境变量，其格式如下所示。

~~~shell
parent=<pathname>/myshell。
~~~





## 批处理文件执行

(三)	 shell 必须能够从文件中提取命令行输入，例如shell 使用以下命令行被调用：

myshell batchfile 

这个批处理文件应该包含一组命令集，当到达文件结尾时shell 退出。很明显，如果shell 被调用时没有使用参数，它会在屏幕上显示提示符请求用户输入。





## I/O 重定向

(四)	 shell 必须支持I/O 重定向，stdin 和stdout，或者其中之一，例如命令行为：
programname arg1 arg2 < inputfile > outputfile 
使用arg1 和arg2 执行程序programname，输入文件流被替换为inputfile，输出文件流被替换为outputfile。
stdout 重定向应该支持以下内部命令：dir、environ、echo、help。
使用输出重定向时，如果重定向字符是>，则创建输出文件，如果存在则覆盖之；如果重定向字符为>>，也会创建输出文件，如果存在则添加到文件尾。



## 后台程序执行

(五)	 shell 必须支持后台程序执行。如果在命令行后添加&字符，在加载完程序后需要立刻返回命令行提示符。





## 管道操作

(六)	 必须支持管道（“|”）操作。



## 路径显示

(七)	 命令行提示符必须包含当前路径。

30 (黑色), 31 (红色), 32 (绿色), 33 (黄色), 34 (蓝色), 35 (洋红), 36 (青色), 37 (白色)





项目要求：
1)	设计一个简单的全新命令行shell，至少满足上面的要求并且在指定的Linux 平台上执行。拒绝使用已有的shell程序的任何环境及功能。严禁使用开源代码。
2)	写一个关于如何使用shell 的简单的用户手册，用户手册应该包含足够的细节以方便Linux初学者使用。例如：你应该解释I/O 重定向、管道、程序环境和后台程序执行。
3)	源代码必须有很详细的注释，并且有很好的组织结构以方便别人阅读和维护；否则会扣除客观的分数。结构和注释好的程序更加易于理解，并且可以保证批改你作业的人不用很费劲地去读你的代码。

vfork() 出来的进程与父进程共享变量，堆栈，内存虚拟地址，子进程修改变量值，父进程对应的变量也变了；

vfork() 出来的子进程会导致父进程挂起（暂停运行），直到子进程调用 _exit() 函数退出，才会继续运行父进程，子进程如果不退出而是 return 会导致异常；

此外 vfork() 子进程也不能使用 exit() 函数来退出，因为这可能会调用到父进程的 exit() 函数，导致父进程退出，并刷新父进程输入输出（stdio）缓存，因此子进程一定是调用 _exit() 函数来退出。

